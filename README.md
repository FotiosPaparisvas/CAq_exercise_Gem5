# Computer Architecture 2024 Gem 5 - Exercise

## Μέρος Πρώτο
1. Για το παράδειγμα του Hello World, χρησιμοποιήσαμε το αρχείο **starter_se.py** το οποίο βοηθάει στην διαμόρφωση ενός συστήματος για την εξομοίωση ενός προγράμματος πάνω σε αυτό. Από αυτό το αρχείο και σε συνδυασμό με την εντολή που χρησιμοποιήσαμε 

   > ./build/ARM/gem5.opt -d hello_result configs/example/arm/starter_se.py --cpu="minor" "tests/test-progs/hello/bin/arm/linux/hello"

   και συγκεκριμένα το flag **--cpu="minor"** διαπιστώνουμε ότι ο επεξεργαστής που θα χρησιμοποιηθεί είναι τύπου **minor** ,δηλαδή ένα απλός επεξεργαστής που εκτελεί τις εντολές με την σειρά που εμφανίζονται (_in-order execution_), ενώ υπάρχουν και άλλοι τύποι διαθέσιμοι. Επίσης παρατηρούμε ότι ο επεξεργαστής θα έχει μόνο **1 πυρήνα** και η συχνότητα λειτουργίας ορίζεται στο **1GHZ**, αφού δεν χρησιμοποιούμε τα αντίστοιχα flag. Όσο αναφορά τις **caches**, το αρχείο θέτει μέγεθος γραμμής της ίσο με **64 bytes** και δύο επίπεδα **L1** και **L2**. Καθώς δεν χρησιμοποιούμε κάποια flags σχετικά με την **μνήμη** ορίζονται οι προεπιλεγμένες τιμές, δηλαδή **DDR3 1600 MHz**, **2 κανάλια** και μέγεθος **2 Gb**. Ακόμα, στο αρχείο δημιουργείται ένας δίαυλος επικοινωνίας εκτός τσιπ, συνδέεται με την θύρα του συστήματος για το φόρτωμα του **_kernel_**, ορίζονται τα **όρια** της μνήμης. Επίσης, υπάρχουν συναρτήσεις που διαχειρίζονται τις εντολές που θα "_τρέξουν_" και που διαχειρίζονται την διαμόρφωση της μνήμης. Τέλος το αρχείο αρχικοποιεί την εξομοίωση και την ξεκινάει.

2. Στο τέλος της εξομοίωσης δημιουργείται ένας φάκελος με τα αρχεία που παράγει ο gem5. Τετοια αρχεία είναι το **stats.txt** και τα **config**. Το πρώτο περιέχει όλες τις πληροφορίες σχετικά με την **εξομοίωση** και την **λειτουργία** του συστήματος, όπως κύκλους ρολογιού, προσπελάσεις μνήμεις κτλπ. Τα config αρχεία περιέχουν όλες τις πληροφορίες με την **διαμόρφωση** του συστήματος. Συγκεκριμένα, τα **config.ini** και **config.json** έχουν παρόμοιες πληροφορίες, απλά το 2ο τις αναπαριστά σε μορφή _json_. 
   * Αν παρατηρήσουμε αυτά τα αρχεία μπορούμε να επαληθεύσουμε τα στοιχεία που έιχε το αρχείο διαμόρφωσης **starter_se.py**.
        ### config.ini
        ```ini
        [system]
        cache_line_size=64
        mem_ranges=0:2147483647

        [system.clk_domain]
        type=SrcClockDomain
        clock=1000

        [system.cpu_cluster.cpus]
        type=MinorCPU
        
        [system.cpu_cluster.cpus.icache]
        type=Cache

        [system.cpu_cluster.cpus.dcache]
        type=Cache
        
        [system.cpu_cluster.l2]
        type=Cache
        
        [system.mem_ctrls0]
        type=DRAMCtrl
        range=0:2147483647:0:1048704

        [system.mem_ctrls1]
        type=DRAMCtrl
        range=0:2147483647:1:1048704 
        ```
    * Όπως αναφέρθηκε προηγουμένως το αρχείο **stats.txt** περιέχει πληροφορίες σχετικά με την εξομοίωση:  
     Το **sim_seconds** είναι ο **συνολικός χρόνος που πέρασε στην εξομοίωση** σε δευτερόλεπτα, δηλαδή ο χρόνος που θα έκανε το πρόγραμμα να τρέξει στον επεξεργαστή του εξομοιούμενου συστήματος.  
     Το **sim_insts** είναι ο **συνολικός αριθμός των εντολών** που εκτελέστηκαν κατά τη διάρκεια της εξομοίωσης, δηλαδή οι εντολές εκτελέστηκαν από τον επεξεργαστή του εξομοιούμενου συστήματος.  
     Το **host_inst_rate** είναι ο **ρυθμός εκτέλεσης εντολών** στον υπολογιστή που φιλοξενεί την εξομοίωση, μετρημένος σε εντολές ανά δευτερόλεπτο. Αυτή η μετρική δείχνει την απόδοση της εξομοίωσης σε σχέση με τον πραγματικό χρόνο.
     * TODO: Το συνολικό νούμερο των "_commited_" εντολών ειναι το system.cpu_cluster.cpus.committedOps             5831 ή system.cpu_cluster.cpus.committedInsts           5027 και στην προκειμένη περίπτωση είναι ίδιο με το sim_ops kai sim_insts αντίστοιχα.
     * H **L2 Cache** προσπελάστηκε συνολικά **474** φορές. Αυτό αναφέρεται στο stats.txt ως **system.cpu_cluster.l2.overall_accesses::total**. TODO: Υπολογισμός προσπελάσεων χωρίς άμεση παροχή από τον εξομοιωτή
3. Σύμφωνα με την βιβλιογραφία του Gem5 υπάρχουν δίαφοροι τύποι επεξεργαστών. Συγκεκριμένα για του in-order execution επεξεργαστες:  
    * **SimpleCPU**: Ένα πολύ βασικό λειτουργικό μοντέλο επεξεργαστή για εξομοιώσεις που δεν χρειάζονται μεγάλη λεπτομέρεια. Χωρίζεται σε 3 κλάσεις:

      * **BaseSimpleCPU**:Μια βασική κλάση που δεν μπορεί να λειτουργήσει ανεξάρτητα. Διαχειρίζεται τη βασική αρχιτεκτονική κατάσταση και τις κοινές λειτουργίες για τα SimpleCPU μοντέλα, όπως interrupts, requests, handlers κλπ.

      * **AtomicSimpleCPU**: Χρησιμοποιεί ατομικές προσβάσεις μνήμης και υπολογίζει μέσο χρόνο πρόσβασης στην cache, παρέχοντας έναν γρήγορο και απλό προσομοιωτή που είναι κατάλληλος για λειτουργικές προσομοιώσεις.

      * **TimingSimpleCPU**: Προσθέτει χρονικές καθυστερήσεις για τις προσβάσεις μνήμης, επιτρέποντας μια πιο ρεαλιστική απεικόνιση χωρίς την πολυπλοκότητα μιας λεπτομερούς προσομοίωσης της μνήμης με τις απαραίτητες συναρτήσεις για την διαχείρισή της​.

    * **MinorCPU**: Ένα μοντέλο in-order CPU με πιο λεπτομερή δομή αγωγού (pipeline) σε σχέση με το SimpleCPU. Έχει μια προκαθορισμένη μορφή αγωγού και διαμορφώσιμες δομές δεδομένων και συμπεριφορές.  Περιλαμβάνει τέσσερα βασικά στάδια: Fetch1, Fetch2, Decode και Execute. Υποστηρίζει Branch Prediction. Σχεδιάστηκε για εφαρμογές που απαιτούν μια πιο λεπτομερή μελέτη συγκεκριμένων στοιχείων και συμπεριφορών στο pipeline, καθώς επιτρέπει με τον τρόπο που έχει σχεδιαστεί την προσομοίωση των εντολών σε αυτό. Παρέχει καλή ισορροπία ανάμεσα στην ταχύτητα προσομοίωσης και το επίπεδο λεπτομέρειας.
    * **HighPerformanceIn-orderCPU**: Ένα μοντέλο επεξεργαστή εν σειρά (in-order) σχεδιασμένο για την προσομοίωση σύγχρονων αρχιτεκτονικών Armv8-A. Το HPI δίνει έμφαση στην επίτευξη υψηλής απόδοσης, διατηρώντας έναν απλό αγωγό εκτέλεσης εν σειρά. Περιλαμβάνει χαρακτηριστικά όπως μηχανισμό πρόβλεψης διακλαδώσεων (branch predictor), ιεραρχία μνήμης με υποστήριξη L1 και L2 cache, καθώς και μεταφραστική μνήμη (TLB) για τη βελτίωση της διαχείρισης διευθύνσεων. Ο επεξεργαστής αυτός είναι κατάλληλος για προσομοιώσεις σε System Call Emulation (SE) και Full System (FS) modes, προσφέροντας ένα ρεαλιστικό μοντέλο για μελέτες σύγχρονων επεξεργαστών Arm​

    * **InOrderCPU**: Ένα παλαιότερο μοντέλο που στοχεύει στη γενική προσομοίωση αγωγών εν σειρά με προσαρμόσιμα στάδια και μοντέλα πρόσβασης πόρων. Επιτρέπει στους ερευνητές να σχεδιάζουν και να προσομοιώνουν νέα δομικά στοιχεία αγωγών, καθιστώντας το χρήσιμο για πειραματισμούς, αν και δεν δίνεται τόσο μεγάλη έμφαση στις τελευταίες εκδόσεις του gem5  

   1. Γράφουμε ένα απλό πρόγραμμα που υλοποιεί την ακολουθία Fibonnaci:
      ```C
      include <stdio.h>

      int main(int argc, char* argv[]) {

      int n = 45; // Predefined number of terms
      int t1 = 0, t2 = 1, nextTerm = 0;

        for (int i = 2; i < n; ++i) {
            nextTerm = t1 + t2;
            t1 = t2;
            t2 = nextTerm;
        }

      // The last Fibonacci number is now in `nextTerm'
      printf("\n%d\n", nextTerm);


      return 0;
      }
      ```
      Το οποίο το κάνουμε compile για ARM επεξεργαστή μέσω της εντολής:
      >$ arm-linux-gnueabihf-gcc --static fibonacci.c -o fibonacci  

      και τρέχουμε τον gem5 με όρισμα το εκτελέσιμο αρχείο που παράχθηκε με την εντολή:
      >/build/ARM/gem5.opt -d fibonacci_TimingSimpleCPU_result configs/example/se.py --cpu-type=CPU --caches -c fibonacci/fibonacci

      όπου CPU, εκτελούμε μια φορά με MinorCPU και μια με TimingSimpleCPU.  
      Τα αποτελέσματα που παίρνουμε στο stats.txt που αφορούν τους χρόνους τόσο της εξομοίωσης όσο και του εξωμοιούμενου προγράμματος είναι τα εξής:  

      ### MinorCPU
      ```txt
      final_tick                                   34845000                       
      host_inst_rate                                 237780                      
      host_mem_usage                                 678752                       
      host_op_rate                                   270950                       
      host_seconds                                     0.04                      
      host_tick_rate                              904929149                       
      sim_freq                                1000000000000                       
      sim_insts                                        9138                       
      sim_ops                                         10430                       
      sim_seconds                                  0.000035                       
      sim_ticks                                    34845000
      ```
      ### TimingSimpleCPU
      ```txt
      final_tick                                   40247000                       
      host_inst_rate                                 756329                       
      host_mem_usage                                 674148                       
      host_op_rate                                   855122                      
      host_seconds                                     0.01                       
      host_tick_rate                             3330713528                       
      sim_freq                                1000000000000                       
      sim_insts                                        9085                       
      sim_ops                                         10323                       
      sim_seconds                                  0.000040                      
      sim_ticks                                    40247000
      ```
   2. Όπως μπορούμε να παρατηρήσουμε από τα παραπάνω αποτελέσματα η διαδικασία εξομοίωσης του προγράμματος στον host
   διαρκεί περισσότερη ώρα στην περίπτωση του MinorCPU, σε σχέση με αυτή του TimingSimpleCPU το οποίο είναι λογικό αφού όπως αναφέραμε ο πρώτος είναι ένα πιο ρεαλιστικό και πιο περίπλοκο μοντέλο επεξεργαστή με περισσότερη υλοποιημένη λογική και πολυπλοκότητα.
   Παρόμοια είναι και η εξήγηση για την διαφορά του ρυθμού εντολών και διεργασιών που εκτελόυνται στον host σε κάθε εξομοίωση.
   Η χρήση της μνήμης στον host δεν διαφέρει κατα πολύ, αφού και στις δύο περιπτώσεις εξομοιώνουμε το ίδιο πρόγραμμα με τις ίδιες απαιτήσεις.
   Αντίθετα, παρατηρόυμε από τα στοιχεία που αφορόυν το εξομοιούμενο πρόγραμμα ότι στην περίπτωση του MinorCPU, ολοκληρώνεται ταχύτερα παρα το ότι εκτελεί περισσότερες εντολές με την ίδια συχνότητα. Η εξήγηση αυτού είναι ότι λόγω του πιο ρεαλιστικόυ μοντέλου του MinorCPU έχει περισσότερες εντολές απο το ιδανικό σενάριο του TimingSimpleCPU και επιπλέον έχει την δυνατότητα για pipelining που κάνει το πρόγραμμα ταχύτερο.
   
   3. Παρατηρώντας το αρχείο stats.txt απο τις προηγούμενες προσομοιώσεις διαπιστώνουμε ότι το ρολόι των επεξεργαστών ήταν στα 2GHz:
      ```
      system.cpu_clk_domain.clock                       500
      ```
      Επομένως θα τρέξουμε το ίδιο πρόγραμμα με διαφορετικό ρολόι για να δούμε πως θα το επηρεάσει. Επιλέγουμε ρολόι στα 3Ghz. Συμφωνα με την βιβλιογραφία θα πρέπει να χρησιμοποιήσουμε στην εντολή που τρέχουμε, το flag:
      >--cpu-clock=3GHz  

      Δεν παρατηρόυμε κάποια σημαντική διαφόρα στα στοιχεία που προκύπτουν πέρα απο το χρόνο sim_ticks και επομένως sim_seconds:
      ### MinorCPU 3GHz
      ```
      sim_seconds                                  0.000033 (0.000035-2GHz)                       
      sim_ticks                                    33079554 (34845000-2GHz)
      ```

      ### TimingSimpleCPU 3GHz
      ```
      sim_seconds                                  0.000036 (0.000040-2GHz)                     
      sim_ticks                                    35699265 (40247000-2GHz)
      ```
      Σύμφωνα με τα παραπάνω δεδομένα μπορούμε να δούμε ότι η αύξηση της συχνότητας του ρολογιού προφανώς δεν έχει γραμμικό αντίκτυπο στον χρόνο του προγράμματος και επίσης διαφέρει σε κάθε μοντέλο, με μεγαλύτερη επίδραση στο δεύτερο και πιο απλό TimingSimpleCPU. Αυτό συμβαίνει επειδή το απλότερο μοντέλο είναι ιδανικό και δεν έχει ρεαλιστικές καθυστερήσεις στο pipelining και στην μνήμη επομένως η συχνότητα επιδρά πιο άμεσα στο συνολικό χρόνο εκτέλεσης.

      Παρατηρώντας το αρχείο config.dot από τις προηγούμενες προσομοιώσεις διαπιστώνουμε ότι ο τύπος της μνήμης ήταν DDR3_1600_8x8. Σύμφωνα με την βιβλιογραφία θα πρέπει να χρησιμοποιήσουμε στην εντολή που τρέχουμε, το flag:
      >--mem-type=DDR4_2400_16x4

      Επιλέγουμε αυτό τον τύπο επειδή σύμφωνα με την βιβλιογραφία έχει το μεγαλύτερο bandwidth.

      Αντίστοιχα με πριν παρατηρούμε διαφορά σε δύο κυρίως μετρικές:
      ### MinorCPU DDR4_2400_16x4
      ```
      sim_seconds                                  0.000034 (0.000035-2GHz)                      
      sim_ticks                                    34113000 (34845000-2GHz)
      ```

      ### TimingSimpleCPU DDR4_2400_16x4
      ```
      sim_seconds                                  0.000040 (0.000040-2GHz)                      
      sim_ticks                                    39874000 (40247000-2GHz)
      ```
      Στην περίπτωση με την μνήμη παρατηρούμε ότι η διαφορά που κάνει στο συγκεκριμένο πρόγραμμα είναι πολύ μικρή αλλά έχει μεγαλύτερη επίδραση στο μοντέλο του MinorCPU. Επειδή αυτό είναι πιο ρεαλιστικό στο κομμάτι της μνήμης και χρησιμοποιεί pipelining που επηρεάζεται από τις καθυστερήσεις μνήμης, η βελτίωση της έχει μεγαλύτερο αντίκτυπο. 








mem types:https://nitish2112.github.io/post/gem5-memory-model/
using se script: https://www.gem5.org/documentation/learning_gem5/part1/example_configs/
SimpleCPU:https://www.gem5.org/documentation/general_docs/cpu_models/SimpleCPU
MinorCPU:https://www.gem5.org/documentation/general_docs/cpu_models/minor_cpu
InOrderCPU:https://old.gem5.org/InOrder.html